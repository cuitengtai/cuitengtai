
 <!DOCTYPE HTML>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
  
    <title>《Effective Objective-C 2.0：编写高质量iOS与OS X代码的52个有效方法》笔记 | 光之晨曦</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="tengtai">
    

    <meta name="keywords" content="编写高质量iOS与OS X代码的52个有效方法">
    <meta name="description" content="编写高质量iOS与OS X代码的52个有效方法">
<meta property="og:type" content="article">
<meta property="og:title" content="《Effective Objective-C 2.0：编写高质量iOS与OS X代码的52个有效方法》笔记">
<meta property="og:url" content="http://www.tengtai.tk/2017/01/22/2017-01-22-Effective Objective-C 2.0：编写高质量iOS与OS X代码的52个有效方法-/index.html">
<meta property="og:site_name" content="光之晨曦">
<meta property="og:description" content="编写高质量iOS与OS X代码的52个有效方法">
<meta property="og:updated_time" content="2017-06-12T03:39:58.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="《Effective Objective-C 2.0：编写高质量iOS与OS X代码的52个有效方法》笔记">
<meta name="twitter:description" content="编写高质量iOS与OS X代码的52个有效方法">

    
    <link rel="alternative" href="/atom.xml" title="光之晨曦" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="光之晨曦" title="光之晨曦"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="光之晨曦">光之晨曦</a></h1>
				<h2 class="blog-motto">The code is artwork and needs to be polished slowly.</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="Search" />
						<input type="hidden" name="q" value="site:www.tengtai.tk">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/01/22/2017-01-22-Effective Objective-C 2.0：编写高质量iOS与OS X代码的52个有效方法-/" title="《Effective Objective-C 2.0：编写高质量iOS与OS X代码的52个有效方法》笔记" itemprop="url">《Effective Objective-C 2.0：编写高质量iOS与OS X代码的52个有效方法》笔记</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="tengtai" target="_blank" itemprop="author">tengtai</a>
		
  <p class="article-time">
    <time datetime="2017-01-21T16:00:00.000Z" itemprop="datePublished"> Published 2017-01-22</time>
    
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">Contents</strong>
		
			<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#熟悉Objective-C"><span class="toc-number">1.</span> <span class="toc-text">熟悉Objective-C</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#了解Objective-C语言的起源"><span class="toc-number">1.1.</span> <span class="toc-text">了解Objective-C语言的起源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#在类的头文件中尽量少引用其他头文件"><span class="toc-number">1.2.</span> <span class="toc-text">在类的头文件中尽量少引用其他头文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多用字面量语法，少用与之等价的方法"><span class="toc-number">1.3.</span> <span class="toc-text">多用字面量语法，少用与之等价的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多用类型常量，少用-define预处理指令"><span class="toc-number">1.4.</span> <span class="toc-text">多用类型常量，少用#define预处理指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多用类型常量，少用-define预处理指令-1"><span class="toc-number">1.5.</span> <span class="toc-text">多用类型常量，少用#define预处理指令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对象、消息、运行期"><span class="toc-number">2.</span> <span class="toc-text">对象、消息、运行期</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#理解“属性”这一概念"><span class="toc-number">2.1.</span> <span class="toc-text">理解“属性”这一概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#在对象内部尽量直接访问实例变量"><span class="toc-number">2.2.</span> <span class="toc-text">在对象内部尽量直接访问实例变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#理解“对象等同性”这一概念"><span class="toc-number">2.3.</span> <span class="toc-text">理解“对象等同性”这一概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#以“类族模式”隐藏实现细节"><span class="toc-number">2.4.</span> <span class="toc-text">以“类族模式”隐藏实现细节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#在既有类中使用关联对象存放自定义数据"><span class="toc-number">2.5.</span> <span class="toc-text">在既有类中使用关联对象存放自定义数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#理解objc-msgSend的作用"><span class="toc-number">2.6.</span> <span class="toc-text">理解objc_msgSend的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#理解消息转发机制"><span class="toc-number">2.7.</span> <span class="toc-text">理解消息转发机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#用“方法调配技术”测试“黑盒方法”"><span class="toc-number">2.8.</span> <span class="toc-text">用“方法调配技术”测试“黑盒方法”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#理解“类对象”的用意"><span class="toc-number">2.9.</span> <span class="toc-text">理解“类对象”的用意</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#接口与API设计"><span class="toc-number">3.</span> <span class="toc-text">接口与API设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#用前缀避免命名空间冲突"><span class="toc-number">3.1.</span> <span class="toc-text">用前缀避免命名空间冲突</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#提供全能的初始化方法"><span class="toc-number">3.2.</span> <span class="toc-text">提供全能的初始化方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实现description方法"><span class="toc-number">3.3.</span> <span class="toc-text">实现description方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#尽量使用不可变对象"><span class="toc-number">3.4.</span> <span class="toc-text">尽量使用不可变对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用清晰而协调的命名方式"><span class="toc-number">3.5.</span> <span class="toc-text">使用清晰而协调的命名方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为私有方法名加前缀"><span class="toc-number">3.6.</span> <span class="toc-text">为私有方法名加前缀</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#理解Objective-C错误模型"><span class="toc-number">3.7.</span> <span class="toc-text">理解Objective-C错误模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#理解NSCopying协议"><span class="toc-number">3.8.</span> <span class="toc-text">理解NSCopying协议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#协议与分类"><span class="toc-number">4.</span> <span class="toc-text">协议与分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#通过委托与数据源协议进行对象间通信"><span class="toc-number">4.1.</span> <span class="toc-text">通过委托与数据源协议进行对象间通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#将类的实现代码分散到便于管理的数个分类之中"><span class="toc-number">4.2.</span> <span class="toc-text">将类的实现代码分散到便于管理的数个分类之中</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总是为第三方类的分类名称加前缀"><span class="toc-number">4.3.</span> <span class="toc-text">总是为第三方类的分类名称加前缀</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#请勿在分类中声明属性"><span class="toc-number">4.4.</span> <span class="toc-text">请勿在分类中声明属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用“class-continuation分类”隐藏实现细节"><span class="toc-number">4.5.</span> <span class="toc-text">使用“class-continuation分类”隐藏实现细节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#通过协议提供匿名对象"><span class="toc-number">4.6.</span> <span class="toc-text">通过协议提供匿名对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内存管理"><span class="toc-number">5.</span> <span class="toc-text">内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#理解引用计数器"><span class="toc-number">5.1.</span> <span class="toc-text">理解引用计数器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#以ARC简化引用计数"><span class="toc-number">5.2.</span> <span class="toc-text">以ARC简化引用计数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#在dealloc方法中只释放引用并解除监听"><span class="toc-number">5.3.</span> <span class="toc-text">在dealloc方法中只释放引用并解除监听</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#编写”异常安全代码“时留意内存管理问题"><span class="toc-number">5.4.</span> <span class="toc-text">编写”异常安全代码“时留意内存管理问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#以弱引用避免保留环"><span class="toc-number">5.5.</span> <span class="toc-text">以弱引用避免保留环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#以”自动释放池块“降低内存峰值"><span class="toc-number">5.6.</span> <span class="toc-text">以”自动释放池块“降低内存峰值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#用”僵尸对象“调试内存管理问题"><span class="toc-number">5.7.</span> <span class="toc-text">用”僵尸对象“调试内存管理问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#不要使用retainCount"><span class="toc-number">5.8.</span> <span class="toc-text">不要使用retainCount</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#块与大中枢派发"><span class="toc-number">6.</span> <span class="toc-text">块与大中枢派发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#理解“块”这一概念"><span class="toc-number">6.1.</span> <span class="toc-text">理解“块”这一概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为常用的块类型创建typedef"><span class="toc-number">6.2.</span> <span class="toc-text">为常用的块类型创建typedef</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#用handler块降低代码分散程度"><span class="toc-number">6.3.</span> <span class="toc-text">用handler块降低代码分散程度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用块引用其所属对象时不要出现保留环"><span class="toc-number">6.4.</span> <span class="toc-text">使用块引用其所属对象时不要出现保留环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多用派发队列，少用同步锁"><span class="toc-number">6.5.</span> <span class="toc-text">多用派发队列，少用同步锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多用GCD，少用performSelector系列方法"><span class="toc-number">6.6.</span> <span class="toc-text">多用GCD，少用performSelector系列方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#掌握GCD及操作队列的使用时机"><span class="toc-number">6.7.</span> <span class="toc-text">掌握GCD及操作队列的使用时机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#通过Dispatch-Group机制，根据系统资源状况来执行任务"><span class="toc-number">6.8.</span> <span class="toc-text">通过Dispatch Group机制，根据系统资源状况来执行任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用dispatch-once来执行只需运行一次的线程安全代码"><span class="toc-number">6.9.</span> <span class="toc-text">使用dispatch_once来执行只需运行一次的线程安全代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#不要使用dispatch-get-current-queue"><span class="toc-number">6.10.</span> <span class="toc-text">不要使用dispatch_get_current_queue</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#系统框架"><span class="toc-number">7.</span> <span class="toc-text">系统框架</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#熟悉系统框架"><span class="toc-number">7.1.</span> <span class="toc-text">熟悉系统框架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多用块枚举，少用for循环"><span class="toc-number">7.2.</span> <span class="toc-text">多用块枚举，少用for循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对自定义其内存管理语义的collection使用无缝桥接"><span class="toc-number">7.3.</span> <span class="toc-text">对自定义其内存管理语义的collection使用无缝桥接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#构建缓存时选用NSCache而非NSDictionary"><span class="toc-number">7.4.</span> <span class="toc-text">构建缓存时选用NSCache而非NSDictionary</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#精简initialize与load的实现代码"><span class="toc-number">7.5.</span> <span class="toc-text">精简initialize与load的实现代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#别忘了NSTimer会保留其目标对象"><span class="toc-number">7.6.</span> <span class="toc-text">别忘了NSTimer会保留其目标对象</span></a></li></ol></li></ol>
		
		</div>
		
		<p>写出优雅高效的代码是每个程序员的最高追求，最近静下心里细细的品味一下一些提高代码质量的技巧，与君共勉之。<br><a id="more"></a></p>
<h2 id="熟悉Objective-C"><a href="#熟悉Objective-C" class="headerlink" title="熟悉Objective-C"></a>熟悉Objective-C</h2><h3 id="了解Objective-C语言的起源"><a href="#了解Objective-C语言的起源" class="headerlink" title="了解Objective-C语言的起源"></a>了解Objective-C语言的起源</h3><p>1、区别于C++, Java等面向对象的语言，Objective-C在 运行中是“消息转发”而非“函数调用”，运行时所执行的代码由运行环境决定，而非编译器决定。<br>2、NSString *someString = @”The string”; someString指针变量被分配在“栈帧”中，@“The string”对象则被分配在“堆空间”中，分配在堆中的内存必须直接管理，而分配在栈上用于保存变量的内存则会在其“栈帧”自动弹出时清理。在Objective-C中，内存管理指的是堆上的这部分内存。</p>
<h3 id="在类的头文件中尽量少引用其他头文件"><a href="#在类的头文件中尽量少引用其他头文件" class="headerlink" title="在类的头文件中尽量少引用其他头文件"></a>在类的头文件中尽量少引用其他头文件</h3><p>1、不要为了省事，直接在头文件中引用其他类的头文件，将头文件引入的时间尽量延后，可以用”@class”来声明类，减少编译器的负担。<br>2、如果两个类互相引入对方的头文件会造成“循环引用”，无法正常编译。经测试：只互相引用头文件可正常编译，但是如果在类里面使用对方头文件变量时，就无法编译通过。<br>3、某个类如果要实现某个协议，尽量把协议的声明写在“类扩展”，即”.m”文件的”@interface xxx<xxxdelegate> @end”,如果实在不行，那就最好吧协议单独放在一个头文件中，然后将其引入。</xxxdelegate></p>
<h3 id="多用字面量语法，少用与之等价的方法"><a href="#多用字面量语法，少用与之等价的方法" class="headerlink" title="多用字面量语法，少用与之等价的方法"></a>多用字面量语法，少用与之等价的方法</h3><p>好处:<br>1、书写简洁，便于阅读。<br>2、使用字面量数组时可以更快的抛出异常，更加安全。<br>局限性:<br>1、自定义创建子类的实例，需要采取“非字面量语法”。</p>
<h3 id="多用类型常量，少用-define预处理指令"><a href="#多用类型常量，少用-define预处理指令" class="headerlink" title="多用类型常量，少用#define预处理指令"></a>多用类型常量，少用#define预处理指令</h3><p><del>#define ANIMATION_DURATION 0.3</del></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">static const NSTimeInterval kAnimationDuration = 0.3</div></pre></td></tr></table></figure>
<p>1、如果不打算公开变量，可在.m文件中，同时使用static和const来定义常量，如果试图修改该变量编译器就会报错。这种变量只在编译单元内可见，由于不在”全局符号表“中所以无需增加前缀。<br>2、如果打算公开某个常量，则需要这样来实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// EOCAnimatedView.h</div><div class="line">extern const NSTimerInterval EOCAnimatedViewAnimationDuration;</div><div class="line">// EOCAnimatedView.m</div><div class="line">const NSTimerInterval EOCAnimatedViewAnimationDuration = 0.3;</div></pre></td></tr></table></figure></p>
<p>在头文件中声明，在实现文件中定义，由于在”全局符号表“中，为避免名称冲突，最好用与之相关的类名作为前缀。这样定义常量是不可被更改的，而使用#define预处理指令定义的常量很可能遭到别人的无意更改，这是非常危险的事情。</p>
<h3 id="多用类型常量，少用-define预处理指令-1"><a href="#多用类型常量，少用-define预处理指令-1" class="headerlink" title="多用类型常量，少用#define预处理指令"></a>多用类型常量，少用#define预处理指令</h3><p>1、使用NS_ENUM与NS_OPTIONS宏来定义枚举类型并指明其数据结构。<br>2、应该用枚举来表示状态机的状态，状态码等值。<br>3、如果枚举的多个选项可以同时组合，将这些项定义为2的幂，以便可以通过按位或操作将其组合起来。<br>例如：AnimationEasyIn | AnimationLeft<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">typedef NS_ENUM(NSUInteger, AnimationBehavior) &#123;</div><div class="line">AnimationEasyIn = 1 &lt;&lt; 0,</div><div class="line">AnimationLeft = 1 &lt;&lt; 1</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>4、处理枚举类型的switch语句中不要实现default分支，这样的话有新枚举加入，编译器就会提示开发者，switch语句中并未处理所有的枚举。</p>
<h2 id="对象、消息、运行期"><a href="#对象、消息、运行期" class="headerlink" title="对象、消息、运行期"></a>对象、消息、运行期</h2><h3 id="理解“属性”这一概念"><a href="#理解“属性”这一概念" class="headerlink" title="理解“属性”这一概念"></a>理解“属性”这一概念</h3><p>1、尽量不要直接定义实例变量，推荐使用属性”@proproty”来合成存取方法。使用点语法调用来访问变量。<br>2、在设置属性所对应的实例变量时，一定要遵循该属性所声明的语义。<br>即：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, copy)NSString *name;</div><div class="line">	</div><div class="line">- (void)setName:(NSString *)name</div><div class="line">&#123;</div><div class="line">    _name = [name copy];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="在对象内部尽量直接访问实例变量"><a href="#在对象内部尽量直接访问实例变量" class="headerlink" title="在对象内部尽量直接访问实例变量"></a>在对象内部尽量直接访问实例变量</h3><p>强烈建议在读取实例变量时候采用直接访问的形式，而在设置实例变量的时候通过属性来做。</p>
<p>理由：<br>1、直接访问属性，而不经过存取方法，直接访问那块内存，速度当然比较快，但是可以忽略不计。<br>2、直接访问属性就绕过了如“strong”、“copy”,等“管理语义”，如果在ARC下直接访问一个声明为copy的对象，并不会拷贝改属性，只会保留新值并释放旧值。<br>3、直接访问实例变量，不会触发“KVO”，<br>合理的方案：<br>在对象内部读取数据时，直接通过实例变量来读，在写入数据时，通过属性来写。<br>注意：<br>1、在初始化方法和dealloc方法中，应该直接访问实例变量，防止子类覆盖设置方法。<br>2、懒加载中，通过获取方法来访问属性，否则实例变量永远不会被初始化。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (Person *)person &#123;</div><div class="line">	if (!_person) &#123;</div><div class="line">		_person = [Person alloc] init];</div><div class="line">	&#125;</div><div class="line">	return _person;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="理解“对象等同性”这一概念"><a href="#理解“对象等同性”这一概念" class="headerlink" title="理解“对象等同性”这一概念"></a>理解“对象等同性”这一概念</h3><p>1、重写isEqual和hash方法，判断对象的等同性。<br>2、利用标识符，类似于数据库的主键，来判断对象的等同性。<br>3、容器中放入可变对象时，慎重改变其哈希码，如：NSMutableSet中加入NSMutableArray。<br>4、不盲目地检查每条属性，按照具体需求来制定检测对象。<br>5、相同的对象必须具有相同的哈希码，但是哈希码相同的对象未必相同。<br>6、编写hash方法时，应该使用计算速度快而且哈希码碰撞几率低的算法。</p>
<p><a href="https://zh.wikipedia.org/wiki/%E5%93%88%E5%B8%8C%E8%A1%A8" target="_blank" rel="external">哈希介绍</a><br><a href="http://nshipster.cn/equality/" target="_blank" rel="external">Equality</a></p>
<h3 id="以“类族模式”隐藏实现细节"><a href="#以“类族模式”隐藏实现细节" class="headerlink" title="以“类族模式”隐藏实现细节"></a>以“类族模式”隐藏实现细节</h3><p>1、使用类方法创建实例，如：+ (UIButton *)buttonWithType:<br>2、从类族的公共抽象基类中继承子类时要当心，子类应当覆写父类中指明需要覆写的方法</p>
<h3 id="在既有类中使用关联对象存放自定义数据"><a href="#在既有类中使用关联对象存放自定义数据" class="headerlink" title="在既有类中使用关联对象存放自定义数据"></a>在既有类中使用关联对象存放自定义数据</h3><p>“关联对象”(Associated Object),可以在外部给类添加属性，常用在Category中添加。</p>
<h3 id="理解objc-msgSend的作用"><a href="#理解objc-msgSend的作用" class="headerlink" title="理解objc_msgSend的作用"></a>理解objc_msgSend的作用</h3><p>1、“静态绑定”编译器在编译阶段就能生成调用函数指令，“动态绑定”运行期才可以生成函数调用指令。<br>2、objc_msgSend函数会在接收者所属类中的“方法列表”中寻找符合的方法，如果找到就执行实现代码，如果找不到，就沿着继承体系，向上继续寻找，如果最终还是找不到，就执行“消息转发操作”，此处可进行手动拦截。<br>3、尾调用优化对于递归具有重要意义，大大减少调用栈的调用记录，防止栈溢出。</p>
<p><a href="http://www.ruanyifeng.com/blog/2015/04/tail-call.html" target="_blank" rel="external">尾调用优化</a></p>
<h3 id="理解消息转发机制"><a href="#理解消息转发机制" class="headerlink" title="理解消息转发机制"></a>理解消息转发机制</h3><p>1、运行时系统没有找到消息的接收者，会发起消息转发，给接收者最后一次机会，所有的细节封装在NSInvocation对象中，在此可以进行拦截处理。<br>2、对象无法收到解读的消息后，首先调用其所属类的类方法：<br>第一步：</p>
<ul>
<li>(BOOL)resolveInstanceMethod:(SEL)selector 此处可以使用class_addMethod()添加新方法。<br>第二步：为消息寻找一个备用的接收者，但无法操作这一步的消息。</li>
</ul>
<ul>
<li>(id)forwardingTargetForSelector:(SEL)selector<br>第三步：若发现某调用操作不应该由本类处理，则需要调用超类的同名方法，这样，继承体系的每个子类都有机会处理此调用请求，直至NSObject,如果最后调用了NSObject的方法，会抛出异常，表明消息未得到处理。</li>
<li>(void)forwardingInvocation:(NSInvocation *)invocation</li>
</ul>
<h3 id="用“方法调配技术”测试“黑盒方法”"><a href="#用“方法调配技术”测试“黑盒方法”" class="headerlink" title="用“方法调配技术”测试“黑盒方法”"></a>用“方法调配技术”测试“黑盒方法”</h3><p>在运行期，通过runtime向类中添加或者交换方法实现。</p>
<h3 id="理解“类对象”的用意"><a href="#理解“类对象”的用意" class="headerlink" title="理解“类对象”的用意"></a>理解“类对象”的用意</h3><p>1、如果类型无法在编译器确定，那么就应该使用类型信息查询方法来探知。isMemberOfClass:判断对象是否为某个类的实例，isKindOfClass:判断对象是否为某个类或者其子类的实例。<br>2、尽量使用类型信息确定对象类型，不要直接比较类对象，因为某些对象可能实现了消息转发功能。<br>如：<br><del>if（[object class] == [Person class]）{<br>}<del><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">if（[object isMemberOfClass:[Person class]] &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></del></del></p>
<h2 id="接口与API设计"><a href="#接口与API设计" class="headerlink" title="接口与API设计"></a>接口与API设计</h2><h3 id="用前缀避免命名空间冲突"><a href="#用前缀避免命名空间冲突" class="headerlink" title="用前缀避免命名空间冲突"></a>用前缀避免命名空间冲突</h3><p>1、选择与你公司，应用程序或者与之相关的名称作为类名前缀，并在所有代码中统一所有前缀。<br>2、在Category中给变量，方法添加前缀。<br>3、若自己所开发的程序中用到了第三方库，则应为其中的名称加上前缀。<br>4、所选的前缀应为三个字母（苹果规定的）。</p>
<h3 id="提供全能的初始化方法"><a href="#提供全能的初始化方法" class="headerlink" title="提供全能的初始化方法"></a>提供全能的初始化方法</h3><p>1、在类中提供一个全能的初始化方法，供其他初始化方法调用。<br>2、若全能初始化方法与超类的不同，则需要覆写超类中对应的方法。<br>3、如果超类的初始化方法不适用于子类，那么应该覆写这个超类方法，并在其中抛出异常。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">-(id)initWithWidth:(float)width andHeight:(float)height</div><div class="line">&#123;</div><div class="line">   @throw [NSException exceptionWithName:...];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="实现description方法"><a href="#实现description方法" class="headerlink" title="实现description方法"></a>实现description方法</h3><p>1、实现description方法返回一串有意义的字符串，来描述该对象，使用NSLog()打印对象时调用。<br>2、实现debugDescription方法返回一串有意义的字符串，来描述该对象，在开发者断点调试通过LLDB命令po对象时调用。</p>
<h3 id="尽量使用不可变对象"><a href="#尽量使用不可变对象" class="headerlink" title="尽量使用不可变对象"></a>尽量使用不可变对象</h3><p>1、尽量把对外部公布出去的属性设置为只读(readonly)<br>2、如果想修改封装在对象内部的数据，但是又不想别人在外部修改，这时需要在.m文件中重新把属性声明为readwrite，但是这样会产生“竞态条件”，需要将对象的所有数据进行同步，参见41条。<br>3、通过KVC仍可以修改只读属性的值，这时不符合API规范的。<br>4、不要把可变的集合对象作为属性公开，而是提供相应的方法修改集合对象。</p>
<h3 id="使用清晰而协调的命名方式"><a href="#使用清晰而协调的命名方式" class="headerlink" title="使用清晰而协调的命名方式"></a>使用清晰而协调的命名方式</h3><p>1、尽量使用长方法名，清晰的说明方法的意思，但是也要尽量言简意赅，可参考UIKit命名规范。</p>
<p><del>-(id)initWithSize:(float)width :(float)height<del><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-(id)initWithWidth:(float)width andHeight:(float)height</div></pre></td></tr></table></figure></del></del></p>
<h3 id="为私有方法名加前缀"><a href="#为私有方法名加前缀" class="headerlink" title="为私有方法名加前缀"></a>为私有方法名加前缀</h3><p>1、给私有方法的名称加上前缀，便于跟公共方法区分。<br>2、不能用单一下划线做前缀，这是苹果私有API的前缀，会冲突。</p>
<h3 id="理解Objective-C错误模型"><a href="#理解Objective-C错误模型" class="headerlink" title="理解Objective-C错误模型"></a>理解Objective-C错误模型</h3><p>1、“-fojc-arc-exception”编译标识可以在执行异常代码时不抛出异常<br>2、异常用于处理致命问题，无需考虑恢复问题，应用程序直接退出，非致命问题使用NSError对象。<br>3、通过“输出参数”方式把NSError对象回传给调用者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">NSError *error = nil;</div><div class="line">BOOL ret = [object doSomething:&amp;error];</div><div class="line">if (ret) &#123;</div><div class="line">   // There was an error</div><div class="line">&#125;</div><div class="line">- (Bool)doSomething:(NSError **)error &#123;</div><div class="line">   if (// there was an error) &#123;</div><div class="line">       if (error) &#123;</div><div class="line">           *error = [NSError errorWithDomain:...];</div><div class="line">       &#125;</div><div class="line">       return NO;</div><div class="line">   &#125; else &#123;</div><div class="line">       return YES;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在error要指向一个新的对象时（解引用），必须先保证error参数不是nil,因为空指针解引用会导致“段错误”，并使应用程序崩溃。调用者在不关心具体错误时，会给error参数传入nil,因此必须判断这种情况。</p>
<h3 id="理解NSCopying协议"><a href="#理解NSCopying协议" class="headerlink" title="理解NSCopying协议"></a>理解NSCopying协议</h3><p>1、想让自定义对象具有拷贝功能，需要实现NSCopying协议。<br>2、对象拷贝分为深拷贝和浅拷贝，一般情况下尽量执行浅拷贝。<br>3、如果对象需要深拷贝，可以考虑增加一个专门执行深拷贝的方法。<br>4、如果自定义对象分为可变和不可变版本，需要同时实现NSCopying和NSMutableCopying协议。</p>
<h2 id="协议与分类"><a href="#协议与分类" class="headerlink" title="协议与分类"></a>协议与分类</h2><h3 id="通过委托与数据源协议进行对象间通信"><a href="#通过委托与数据源协议进行对象间通信" class="headerlink" title="通过委托与数据源协议进行对象间通信"></a>通过委托与数据源协议进行对象间通信</h3><p>1、委托模式为对象提供一套接口，通过接口可将相关事件告知其他对象。<br>2、将委托对象应该支持的接口定义成协议，在协议中将可能需要处理的事件定义为方法。<br>3、当使用委托模式传递数据时，该模式也叫“数据源协议”，如UITableViewDataSource<br>4、使用“位域”（含有位段的结构体），将委托对象是否响应相关协议的信息缓存其中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">struct &#123;</div><div class="line">   unsigned int didReceiveData : 1;</div><div class="line">   unsigned int didFailWithError : 1;</div><div class="line">   unsigned int didUpdateProgressTo : 1;</div><div class="line">&#125; _delegateFlags;</div><div class="line">    </div><div class="line">- (void)setDelegate:(id&lt;...&gt;)delegate &#123;</div><div class="line">   _delegateFlags.didReceiveData = [delegate respondsToSelector:@selctor(...)];</div><div class="line">&#125;</div><div class="line">    </div><div class="line">if (_delegateFlags.didReceiveData) &#123;</div><div class="line">   [_delegate ....];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="将类的实现代码分散到便于管理的数个分类之中"><a href="#将类的实现代码分散到便于管理的数个分类之中" class="headerlink" title="将类的实现代码分散到便于管理的数个分类之中"></a>将类的实现代码分散到便于管理的数个分类之中</h3><p>1、使用分类机制把类的实现代码划分成易于管理的小块。<br>2、将应该私有的方法归入名叫Private的分类中，以隐藏实现细节。</p>
<h3 id="总是为第三方类的分类名称加前缀"><a href="#总是为第三方类的分类名称加前缀" class="headerlink" title="总是为第三方类的分类名称加前缀"></a>总是为第三方类的分类名称加前缀</h3><p>1、如果多个分类重载“主实现”的相关方法，以最后一个分类为主，即：分类在项目中编译的顺序。<br>2、以命名空间来区分分类中所定义的方法，三个小写字母加下划线:abc_xxx</p>
<h3 id="请勿在分类中声明属性"><a href="#请勿在分类中声明属性" class="headerlink" title="请勿在分类中声明属性"></a>请勿在分类中声明属性</h3><p>1、分类不可以定义属性，如果非要这么做，可以使用“关联对象”。<br>2、把封装数据所用的全部属性都定义在主类中。<br>3、可以定义存取方法但是尽量不要定义属性。</p>
<h3 id="使用“class-continuation分类”隐藏实现细节"><a href="#使用“class-continuation分类”隐藏实现细节" class="headerlink" title="使用“class-continuation分类”隐藏实现细节"></a>使用“class-continuation分类”隐藏实现细节</h3><p>“class-continuation分类”也叫“类扩展”。<br>1、通过“class-continuation分类”，向类中增加实例变量。<br>2、私有方法声明在“class-continuation分类”中。<br>3、私有的协议也可以声明在“class-continuation分类”中。</p>
<h3 id="通过协议提供匿名对象"><a href="#通过协议提供匿名对象" class="headerlink" title="通过协议提供匿名对象"></a>通过协议提供匿名对象</h3><p>1、协议可以在某种程度上提供匿名类型，具体对象类型可以淡化为遵从某一协议的id类型，协议里规定了对象所应该实现的方法。<br>2、使用匿名对象id<xxx>来隐藏类型名称。<br>3、如果具体类型不重要，重要的是对象能够响应协议里的特定方法，那么可以用匿名对象来表示。也就是说，只暴露使用者关心的，隐藏其不需要关注的。</xxx></p>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="理解引用计数器"><a href="#理解引用计数器" class="headerlink" title="理解引用计数器"></a>理解引用计数器</h3><p>1、非ARC通过引用计数器增减来管理内存，对象创建好之后，引用计数器至少为1，若引用计数为正，对    象继续存活，当保留计数降为0时，对象就被销毁了。<br>2、在对象生命周期中，其他对象通过引用来保留或者释放此对象，保留与释放操作分别会使引用计数递增和递减。<br>3、不要操作“悬挂指针”（野指针），会引起崩溃，最好将其变为“空指针”。<br>4、set方法 strong retain新值，release旧值，然后赋值。<br>5、autoreleasepool能延长对象生命期，在下次运行循环或者更早一些release对象。<br>6、使用“弱引用”可以防止循环引用。</p>
<h3 id="以ARC简化引用计数"><a href="#以ARC简化引用计数" class="headerlink" title="以ARC简化引用计数"></a>以ARC简化引用计数</h3><p>1、ARC会自动补上引用计数代码，但是并没有使用Objective-C的消息转发，而是直接通过C代码，性能会更好。<br>2、ARC只管理Objective-C对象的内存，CoreFoundation对象不归ARC管理，开发者必须适时调用CFRetain/CFRelease。<br>3、ARC对引用计数进行了特殊优化，如果发现对象在运行期进行多次保留和释放操作，会成对的移除这些操作，只保留有用操作，从而提高效率。<br>4、ARC对存取方法进行了优化，不需要再去关注先保留新值，再释放旧值，直接赋值即可。<br>5、ARC借助Objective-C++的特性清理对象，回收Objective-C对象调用多有C++对象的“析构函数”，如发现某个对象里面有C++对象，会生成.cxx_destruct的方法，并在该方法中生成清理内存所需代码。如果有非Objective-C对象（CoreFoundation对象或者malloc()分配的堆内存），不会调用父类的dealloc方法，会生成.cxx_destruct的方法，并在该方法中生成清理内存所需代码，在生成的代码中自动调用父类的dealloc方法。因此可以这样写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">-(void)dealloc &#123;</div><div class="line">   CFRelease(...);</div><div class="line">   free(...);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="在dealloc方法中只释放引用并解除监听"><a href="#在dealloc方法中只释放引用并解除监听" class="headerlink" title="在dealloc方法中只释放引用并解除监听"></a>在dealloc方法中只释放引用并解除监听</h3><p>1、可以在dealloc方法中注销通知观察者等。<br>2、比如文件，套接字，大块内存等开销较大或者系统内稀缺资源不可以在dealloc方法中释放，需要用完即释放。<br>3、系统并不能保证每个创建的对象的dealloc方法都会调用，个别对象在应用程序终止时仍处于存活状态，由于应用程序终止，将内存返还给操作系统，所以实际上这些对象也算是销毁了。所以在系统回收之前我们可以手动清理这些对象，在UIApplicationDelegate/NSApplicationDelegate的委托方法中处理比较合适。<br>4、不要再dealloc方法中随便调用别的方法，存取方法也不要调用，因为这样可能会触发观察者，还是使用下划线比较稳妥。</p>
<h3 id="编写”异常安全代码“时留意内存管理问题"><a href="#编写”异常安全代码“时留意内存管理问题" class="headerlink" title="编写”异常安全代码“时留意内存管理问题"></a>编写”异常安全代码“时留意内存管理问题</h3><p>1、捕获异常时，一定要将try块内的对象清理干净。<br>2、在默认情况下，ARC不生成安全处理异常所需的清理代码，开启”-fobjc-arc-exceptions“标识后，可生成这种代码，不过会导致应用程序变大，而且会降低运行效率。<br>3、如果发现大量异常捕获操作时，考虑使用NSError错误传递来重构。</p>
<h3 id="以弱引用避免保留环"><a href="#以弱引用避免保留环" class="headerlink" title="以弱引用避免保留环"></a>以弱引用避免保留环</h3><p>1、某些引用设置为weak可以避免出现”保留环“（循环引用）。<br>2、weak与unsafe_unretained的区别：<br>相同：都是弱引用，用来表示”非拥有关系“。<br>不同：weak 系统如果把属性回收，属性自动设置为nil；unsafe_unretained 系统如果把属性回收，属性仍然指向那个已经回收的实例，也就是”野指针“，继续操作属性会使程序崩溃，<br>总的来说，weak更加安全一些，但是性能比unsafe_unretained低些。<br>3、一般来说，如果不拥有某个对象就不要去保留它。这条规则对集合类对象例外，因为集合类对象并不直接拥有其内容，而是通过自己内部的元素来保留这个对象。使用weak尽量也不要去使用一个已经释放的弱引用对象，尽管不会崩溃，但是这依然是一个bug。</p>
<h3 id="以”自动释放池块“降低内存峰值"><a href="#以”自动释放池块“降低内存峰值" class="headerlink" title="以”自动释放池块“降低内存峰值"></a>以”自动释放池块“降低内存峰值</h3><p>1、自动释放池排布在栈中，对象收到autorelease消息后，系统将其放入最顶端的池里。<br>2、合理利用自动释放池可以降低内存峰值，如：在for循环内部使用自动释放池包裹代码。<br>3、@autoreleasepool这种写法可以创建更轻便的自动释放池。</p>
<h3 id="用”僵尸对象“调试内存管理问题"><a href="#用”僵尸对象“调试内存管理问题" class="headerlink" title="用”僵尸对象“调试内存管理问题"></a>用”僵尸对象“调试内存管理问题</h3><p>1、系统再回收对象时，可以不将其真的回收，而是把它转化成僵尸对象，通过环境变量NSZombieEnabled可以开启此功能。<br>2、系统会修改对象的isa指针，另其指向特殊的僵尸类，从而使该对象变为僵尸对象，僵尸类能够响应所有的选择子，响应方式为：打印一条包含信息内容及接收者的消息，然后终止程序。</p>
<h3 id="不要使用retainCount"><a href="#不要使用retainCount" class="headerlink" title="不要使用retainCount"></a>不要使用retainCount</h3><p>1、在ARC中retainCount方法已经被废弃，因为它只能返回特定时间点的引用计数器，而未考虑系统稍后会吧自动释放池清空的情况。或者是retainCount永远不返回0，因为系统可能会优化对象的释放行为，在引用计数是1的时候就回收对象，引用计数可能永远不会是0，所以引用计数是不准确的，就算能够正常返回时凭运气。<br>2、单例对象的引用计数是不会改变的，其保留和释放都是空操作，retainCount已经被废弃了，任何对象的retainCount都是不确定的，所以retainCount绝对不要用。</p>
<h2 id="块与大中枢派发"><a href="#块与大中枢派发" class="headerlink" title="块与大中枢派发"></a>块与大中枢派发</h2><h3 id="理解“块”这一概念"><a href="#理解“块”这一概念" class="headerlink" title="理解“块”这一概念"></a>理解“块”这一概念</h3><p>1、默认情况，block所捕获的变量不能被修改，声明变量时加上<strong>block就可以修改。但是类的实例变量不需要加</strong>block即可被修改。<br>2、使用block小心因捕获了self而造成循环引用的情况。如果访问了类的实例变量，self也会被捕获。<br>3、block可以分配在栈或者堆上，也可以是全局的。分配在栈上的block可以拷贝到堆上，这样的话，就和标准的Objective-C对象一样，具备引用计数了。<br>4、全局的block无法捕获任何状态（变量），运行时也无需状态参与，所使用的内存区域在编译时就确定了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">void (^block)() = ^&#123;</div><div class="line">   NSLog(&quot;This is a block!&quot;);</div><div class="line">&#125;；</div></pre></td></tr></table></figure></p>
<h3 id="为常用的块类型创建typedef"><a href="#为常用的块类型创建typedef" class="headerlink" title="为常用的块类型创建typedef"></a>为常用的块类型创建typedef</h3><p>1、以typedef重新定义block类型，可令块block变量用起来更加简单，可读性更好。<br>2、定义新类型时遵循现有命名习惯，不要发生命名冲突。<br>3、不妨为同一个block定义多个类型别名，如果要重构的代码使用了block类型的某个别名，那么只需修改相应typedef中的签名即可，无需改动其他typedef。</p>
<h3 id="用handler块降低代码分散程度"><a href="#用handler块降低代码分散程度" class="headerlink" title="用handler块降低代码分散程度"></a>用handler块降低代码分散程度</h3><p>1、使用block来取代delegate可以使代码更加紧凑，便于阅读。<br>2、在网络请求的API设计中，尽量用一个handlerl来处理数据及错误，更加灵活。<br>推荐：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[fetcher startWithCompletionHander:^(NSData *data, NSError *error)&#123;</div><div class="line">   if (error) &#123;</div><div class="line">       // failed</div><div class="line">   &#125; else &#123;</div><div class="line">       // success</div><div class="line">   &#125;</div><div class="line">&#125;];</div></pre></td></tr></table></figure></p>
<p>不推荐：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[fetcher startWithCompletionHandler:^(NSData *data)&#123;</div><div class="line">   // success</div><div class="line">&#125; failureHandler:^(NSError *error)&#123;</div><div class="line">   // failed</div><div class="line">&#125;];</div></pre></td></tr></table></figure></p>
<p>3、设计API是如果用到handler块，可以增加一个参数，使调用者可以通过此参数来决定应该把块安排在哪个队列执行。</p>
<h3 id="使用块引用其所属对象时不要出现保留环"><a href="#使用块引用其所属对象时不要出现保留环" class="headerlink" title="使用块引用其所属对象时不要出现保留环"></a>使用块引用其所属对象时不要出现保留环</h3><p>1、如果块所捕获的对象直接或者间接保留了块本身，那么就会造成保留环问题。<br>2、一定要找一个适当的时机解除保留环，而不能把责任推给API的调用者。<br>以下是两种会出现保留环的写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">1、_fetcher捕获了block block捕获了_fetcher</div><div class="line">_fetcher = [[xxx alloc] init];// 属性</div><div class="line">[_fetcher startWithCompletionHander:^(NSData *data, NSError *error)&#123;</div><div class="line">       NSLog(@&quot;%@&quot;, fetcher.url);</div><div class="line">       _fetchData = data;</div><div class="line">&#125;];</div><div class="line">2、fetcher捕获了block block捕获了fetcher.url</div><div class="line">xxx *fetcher = [[xxx alloc] init];// 临时变量</div><div class="line">[fetcher startWithCompletionHander:^(NSData *data, NSError *error)&#123;</div><div class="line">       NSLog(@&quot;%@&quot;, fetcher.url);</div><div class="line">       _fetchData = data;</div><div class="line">&#125;];</div></pre></td></tr></table></figure></p>
<p>解决方案：<br>1、weakSelf和strongSelf。<br>2、在block调用后置为nil。</p>
<h3 id="多用派发队列，少用同步锁"><a href="#多用派发队列，少用同步锁" class="headerlink" title="多用派发队列，少用同步锁"></a>多用派发队列，少用同步锁</h3><p>1、使用锁可以用来实现同步机制，但会带来性能甚至死锁的问题。<br>2、将同步与异步派发结合起来，可以实现与普通锁一样的同步行为，而这么做也不会阻塞执行异步派发的线程。<br>3、使用同步队列及栅栏块（dispatch_barrier_xxx），可以令同步行为更加高效。</p>
<h3 id="多用GCD，少用performSelector系列方法"><a href="#多用GCD，少用performSelector系列方法" class="headerlink" title="多用GCD，少用performSelector系列方法"></a>多用GCD，少用performSelector系列方法</h3><p>1、使用[object performSelector:@selector(selectorName)]方法可能会造成内存泄漏，ARC不会添加相关的释放操作，因此有可能会造成内存泄漏。<br>2、可以使用GCD来代替。</p>
<h3 id="掌握GCD及操作队列的使用时机"><a href="#掌握GCD及操作队列的使用时机" class="headerlink" title="掌握GCD及操作队列的使用时机"></a>掌握GCD及操作队列的使用时机</h3><p>1、GCD并不是最优的办法，在某些情况下使用操作队列（NSOperation）可能会更好一些。<br>2、NSOperation的优势：取消某个操作，制定操作的依赖关系，通过KVO监控NSOperation对象属性，指定操作优先级。<br>3、GCD基于任务的队列，NSOperation基于操作的队列。</p>
<h3 id="通过Dispatch-Group机制，根据系统资源状况来执行任务"><a href="#通过Dispatch-Group机制，根据系统资源状况来执行任务" class="headerlink" title="通过Dispatch Group机制，根据系统资源状况来执行任务"></a>通过Dispatch Group机制，根据系统资源状况来执行任务</h3><p>1、一系列任务可放在一个dispatch group中，开发者可以在这组任务执行完获得通知。<br>2、通过dispatch group，可以并发执行多项任务，GCD会根据系统资源来调度执行任务。</p>
<h3 id="使用dispatch-once来执行只需运行一次的线程安全代码"><a href="#使用dispatch-once来执行只需运行一次的线程安全代码" class="headerlink" title="使用dispatch_once来执行只需运行一次的线程安全代码"></a>使用dispatch_once来执行只需运行一次的线程安全代码</h3><p>1、使用dispatch_once实现单例可以保证线程安全。<br>2、标记声明为static或者global作用域中，这样可以保证执行dispatch_once函数时，传入的标记也是相同的。</p>
<h3 id="不要使用dispatch-get-current-queue"><a href="#不要使用dispatch-get-current-queue" class="headerlink" title="不要使用dispatch_get_current_queue"></a>不要使用dispatch_get_current_queue</h3><p>1、dispatch_get_current_queue已经废弃，最好不要使用，可能会产生死锁问题。</p>
<h2 id="系统框架"><a href="#系统框架" class="headerlink" title="系统框架"></a>系统框架</h2><h3 id="熟悉系统框架"><a href="#熟悉系统框架" class="headerlink" title="熟悉系统框架"></a>熟悉系统框架</h3><p>请记住：用纯C写成的框架与用Objective-C写成的一样重要，若想成为优秀的Objective-C开发者，应掌握C语言的核心概念。</p>
<h3 id="多用块枚举，少用for循环"><a href="#多用块枚举，少用for循环" class="headerlink" title="多用块枚举，少用for循环"></a>多用块枚举，少用for循环</h3><p>1、遍历集合有四种方式，最基本的办法是for循环，其次是NSEnumerator遍历法及快速遍历法，最新，最先进的方式是“块枚举法”，也就是block。<br>2.“块枚举法”通过GCD并发执行遍历操作，效率较高，推荐使用。<br>3、若提前知道待遍历的collection含有何种对象，则应修改块签名，指出对象的类型。</p>
<h3 id="对自定义其内存管理语义的collection使用无缝桥接"><a href="#对自定义其内存管理语义的collection使用无缝桥接" class="headerlink" title="对自定义其内存管理语义的collection使用无缝桥接"></a>对自定义其内存管理语义的collection使用无缝桥接</h3><p>1、<strong>bridge本身意思是：ARC仍然具备这个Objective-C对象的所有权。</strong>bridge_retained则与之相反，意味着ARC交出所有权，后面需要加上CFRelease()以释放对象。<br>2、通过无缝桥接技术，可以在Foundation框架中的Objective-C对象与CoreFoundation框架中的C语言数据结构之间来回转换。<br>2、在CoreFoundation层面创建collection时，可以指定许多回调函数，这些函数表示此collection应该如何处理元素，然后，可以运用无缝桥接技术，将其转换成具备特殊内存管理语义的Objective-C collection。</p>
<h3 id="构建缓存时选用NSCache而非NSDictionary"><a href="#构建缓存时选用NSCache而非NSDictionary" class="headerlink" title="构建缓存时选用NSCache而非NSDictionary"></a>构建缓存时选用NSCache而非NSDictionary</h3><p>1、NSCache胜过NSDictionary之处在于，当系统资源将要耗尽时，他可以自动删减缓存。NSCache并不会“拷贝”键，而是会”保留“它，而且是线程安全的。<br>2、可以给NSCache对象设置上限，用以限制缓存中的对象总个数及“总成本”，而这些尺度则定义了缓存删减其中对象的时机。但是绝对不要把这些尺度当成可靠的“硬限制”，他们仅对NSCache起到指导作用。<br>3、将NSPurgeableData与NSCache搭配使用，可实现自动清除数据的功能，也就是说当NSPurgeableData对象所占内存为系统所丢弃时，该对象自身也将从缓存中清除。<br>4、如果缓存使用得当，那么应用程序的响应速度就能提高。只有那种“重新计算起来很费事的”数据，才值得放入缓存，比如那些需要从网络获取或者从磁盘中读取的数据。</p>
<h3 id="精简initialize与load的实现代码"><a href="#精简initialize与load的实现代码" class="headerlink" title="精简initialize与load的实现代码"></a>精简initialize与load的实现代码</h3><p>1、+ (void)load 当包含类或者分类的程序载入系统时，就会执行此方法，通常是指程序启动的时候，此时运行时是混乱的状态，如果使用了其他的类，其他的类并不一定是初始化好了的。<br>2、load方法的实现尽量精简，它不遵循那套继承规则，很难确定执行顺序，且load方式执行时应用会阻塞，如果在该方法里面执行了大量的耗时操作，那么程序就会无响应，所以一般不要使用此方法。<br>3、+(void)initialize 会在程序首次使用该类之前调用，且只调用一次。与load方法的区别：首先它是“惰性”调用，只有程序在用到该类才会调用。此时运行时是正常状态，且执行环境是线程安全的。<br>4、在编写load方法与initialize要保证代码实现尽量简单，除了初始化全局属性外，最好也不要调用自己的其他的方法。如：无法再编译期设定的全局常量，可以放在initialize方法里面初始化。</p>
<h3 id="别忘了NSTimer会保留其目标对象"><a href="#别忘了NSTimer会保留其目标对象" class="headerlink" title="别忘了NSTimer会保留其目标对象"></a>别忘了NSTimer会保留其目标对象</h3><p>1、NSTimer对象会保留其目标对象，直到计时器本身失效为止，调用invalidate方法可令计时器失效，另外，一次性的计时器在触发完任务之后也会失效。<br>2、反复执行任务的计时器很容易引入保留环，如果计时器的目标对象又保留了计时器本身，那么肯定会导致保留环，这种保留环关系，可能是由于直接或者间接发生的。<br>3、可以扩充NSTimer的功能，用block来打破保留环。<br>   // 把block作为userInfo的参数传入，一定要先拷贝到堆上，不然一会执行block时可能就被释放了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">+ (void)_yy_ExecBlock:(NSTimer *)timer &#123;</div><div class="line">  if ([timer userInfo]) &#123;</div><div class="line">      void (^block)(NSTimer *timer) = (void (^)(NSTimer *timer))[timer userInfo];</div><div class="line">      block(timer);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)seconds </div><div class="line">                                     block:(void (^)(NSTimer *timer))block </div><div class="line">                                   repeats:(BOOL)repeats &#123;</div><div class="line">                                 </div><div class="line">  return [NSTimer scheduledTimerWithTimeInterval:seconds </div><div class="line">                                          target:self</div><div class="line">                                        selector:@selector(_yy_ExecBlock:)</div><div class="line">                                        userInfo:[block copy]</div><div class="line">                                         repeats:repeats];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS/">iOS</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/读书笔记/">读书笔记</a>
  </div>

</div>



	<div class="article-share" id="share">
	
	  <div data-url="http://www.tengtai.tk/2017/01/22/2017-01-22-Effective Objective-C 2.0：编写高质量iOS与OS X代码的52个有效方法-/" data-title="《Effective Objective-C 2.0：编写高质量iOS与OS X代码的52个有效方法》笔记 | 光之晨曦" data-tsina="null" class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2017/01/23/2017-01-23-快速了解JavaScript中的函数/" title="快速了解JavaScript中的函数">
  <strong>上一篇：</strong><br/>
  <span>
  快速了解JavaScript中的函数</span>
</a>
</div>


<div class="next">
<a href="/2015/08/26/2015-08-26-UITableView的分割线/"  title="UITableView的分割线">
 <strong>下一篇：</strong><br/> 
 <span>UITableView的分割线
</span>
</a>
</div>

</nav>

	
<section id="comments" class="comment">
	<div class="ds-thread" data-thread-key="2017/01/22/2017-01-22-Effective Objective-C 2.0：编写高质量iOS与OS X代码的52个有效方法-/" data-title="《Effective Objective-C 2.0：编写高质量iOS与OS X代码的52个有效方法》笔记" data-url="http://www.tengtai.tk/2017/01/22/2017-01-22-Effective Objective-C 2.0：编写高质量iOS与OS X代码的52个有效方法-/"></div>
</section>


</div>  
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">Contents</strong>
 
 <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#熟悉Objective-C"><span class="toc-number">1.</span> <span class="toc-text">熟悉Objective-C</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#了解Objective-C语言的起源"><span class="toc-number">1.1.</span> <span class="toc-text">了解Objective-C语言的起源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#在类的头文件中尽量少引用其他头文件"><span class="toc-number">1.2.</span> <span class="toc-text">在类的头文件中尽量少引用其他头文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多用字面量语法，少用与之等价的方法"><span class="toc-number">1.3.</span> <span class="toc-text">多用字面量语法，少用与之等价的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多用类型常量，少用-define预处理指令"><span class="toc-number">1.4.</span> <span class="toc-text">多用类型常量，少用#define预处理指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多用类型常量，少用-define预处理指令-1"><span class="toc-number">1.5.</span> <span class="toc-text">多用类型常量，少用#define预处理指令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对象、消息、运行期"><span class="toc-number">2.</span> <span class="toc-text">对象、消息、运行期</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#理解“属性”这一概念"><span class="toc-number">2.1.</span> <span class="toc-text">理解“属性”这一概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#在对象内部尽量直接访问实例变量"><span class="toc-number">2.2.</span> <span class="toc-text">在对象内部尽量直接访问实例变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#理解“对象等同性”这一概念"><span class="toc-number">2.3.</span> <span class="toc-text">理解“对象等同性”这一概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#以“类族模式”隐藏实现细节"><span class="toc-number">2.4.</span> <span class="toc-text">以“类族模式”隐藏实现细节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#在既有类中使用关联对象存放自定义数据"><span class="toc-number">2.5.</span> <span class="toc-text">在既有类中使用关联对象存放自定义数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#理解objc-msgSend的作用"><span class="toc-number">2.6.</span> <span class="toc-text">理解objc_msgSend的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#理解消息转发机制"><span class="toc-number">2.7.</span> <span class="toc-text">理解消息转发机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#用“方法调配技术”测试“黑盒方法”"><span class="toc-number">2.8.</span> <span class="toc-text">用“方法调配技术”测试“黑盒方法”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#理解“类对象”的用意"><span class="toc-number">2.9.</span> <span class="toc-text">理解“类对象”的用意</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#接口与API设计"><span class="toc-number">3.</span> <span class="toc-text">接口与API设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#用前缀避免命名空间冲突"><span class="toc-number">3.1.</span> <span class="toc-text">用前缀避免命名空间冲突</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#提供全能的初始化方法"><span class="toc-number">3.2.</span> <span class="toc-text">提供全能的初始化方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实现description方法"><span class="toc-number">3.3.</span> <span class="toc-text">实现description方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#尽量使用不可变对象"><span class="toc-number">3.4.</span> <span class="toc-text">尽量使用不可变对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用清晰而协调的命名方式"><span class="toc-number">3.5.</span> <span class="toc-text">使用清晰而协调的命名方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为私有方法名加前缀"><span class="toc-number">3.6.</span> <span class="toc-text">为私有方法名加前缀</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#理解Objective-C错误模型"><span class="toc-number">3.7.</span> <span class="toc-text">理解Objective-C错误模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#理解NSCopying协议"><span class="toc-number">3.8.</span> <span class="toc-text">理解NSCopying协议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#协议与分类"><span class="toc-number">4.</span> <span class="toc-text">协议与分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#通过委托与数据源协议进行对象间通信"><span class="toc-number">4.1.</span> <span class="toc-text">通过委托与数据源协议进行对象间通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#将类的实现代码分散到便于管理的数个分类之中"><span class="toc-number">4.2.</span> <span class="toc-text">将类的实现代码分散到便于管理的数个分类之中</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总是为第三方类的分类名称加前缀"><span class="toc-number">4.3.</span> <span class="toc-text">总是为第三方类的分类名称加前缀</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#请勿在分类中声明属性"><span class="toc-number">4.4.</span> <span class="toc-text">请勿在分类中声明属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用“class-continuation分类”隐藏实现细节"><span class="toc-number">4.5.</span> <span class="toc-text">使用“class-continuation分类”隐藏实现细节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#通过协议提供匿名对象"><span class="toc-number">4.6.</span> <span class="toc-text">通过协议提供匿名对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内存管理"><span class="toc-number">5.</span> <span class="toc-text">内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#理解引用计数器"><span class="toc-number">5.1.</span> <span class="toc-text">理解引用计数器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#以ARC简化引用计数"><span class="toc-number">5.2.</span> <span class="toc-text">以ARC简化引用计数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#在dealloc方法中只释放引用并解除监听"><span class="toc-number">5.3.</span> <span class="toc-text">在dealloc方法中只释放引用并解除监听</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#编写”异常安全代码“时留意内存管理问题"><span class="toc-number">5.4.</span> <span class="toc-text">编写”异常安全代码“时留意内存管理问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#以弱引用避免保留环"><span class="toc-number">5.5.</span> <span class="toc-text">以弱引用避免保留环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#以”自动释放池块“降低内存峰值"><span class="toc-number">5.6.</span> <span class="toc-text">以”自动释放池块“降低内存峰值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#用”僵尸对象“调试内存管理问题"><span class="toc-number">5.7.</span> <span class="toc-text">用”僵尸对象“调试内存管理问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#不要使用retainCount"><span class="toc-number">5.8.</span> <span class="toc-text">不要使用retainCount</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#块与大中枢派发"><span class="toc-number">6.</span> <span class="toc-text">块与大中枢派发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#理解“块”这一概念"><span class="toc-number">6.1.</span> <span class="toc-text">理解“块”这一概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为常用的块类型创建typedef"><span class="toc-number">6.2.</span> <span class="toc-text">为常用的块类型创建typedef</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#用handler块降低代码分散程度"><span class="toc-number">6.3.</span> <span class="toc-text">用handler块降低代码分散程度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用块引用其所属对象时不要出现保留环"><span class="toc-number">6.4.</span> <span class="toc-text">使用块引用其所属对象时不要出现保留环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多用派发队列，少用同步锁"><span class="toc-number">6.5.</span> <span class="toc-text">多用派发队列，少用同步锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多用GCD，少用performSelector系列方法"><span class="toc-number">6.6.</span> <span class="toc-text">多用GCD，少用performSelector系列方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#掌握GCD及操作队列的使用时机"><span class="toc-number">6.7.</span> <span class="toc-text">掌握GCD及操作队列的使用时机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#通过Dispatch-Group机制，根据系统资源状况来执行任务"><span class="toc-number">6.8.</span> <span class="toc-text">通过Dispatch Group机制，根据系统资源状况来执行任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用dispatch-once来执行只需运行一次的线程安全代码"><span class="toc-number">6.9.</span> <span class="toc-text">使用dispatch_once来执行只需运行一次的线程安全代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#不要使用dispatch-get-current-queue"><span class="toc-number">6.10.</span> <span class="toc-text">不要使用dispatch_get_current_queue</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#系统框架"><span class="toc-number">7.</span> <span class="toc-text">系统框架</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#熟悉系统框架"><span class="toc-number">7.1.</span> <span class="toc-text">熟悉系统框架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多用块枚举，少用for循环"><span class="toc-number">7.2.</span> <span class="toc-text">多用块枚举，少用for循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对自定义其内存管理语义的collection使用无缝桥接"><span class="toc-number">7.3.</span> <span class="toc-text">对自定义其内存管理语义的collection使用无缝桥接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#构建缓存时选用NSCache而非NSDictionary"><span class="toc-number">7.4.</span> <span class="toc-text">构建缓存时选用NSCache而非NSDictionary</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#精简initialize与load的实现代码"><span class="toc-number">7.5.</span> <span class="toc-text">精简initialize与load的实现代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#别忘了NSTimer会保留其目标对象"><span class="toc-number">7.6.</span> <span class="toc-text">别忘了NSTimer会保留其目标对象</span></a></li></ol></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">

  
<div class="categorieslist">
	<p class="asidetitle">Categories</p>
		<ul>
		
		  
			<li><a href="/categories/JavaScript/" title="JavaScript">JavaScript<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Mac工具/" title="Mac工具">Mac工具<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/Python/" title="Python">Python<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS/" title="iOS">iOS<sup>11</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">Tags</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/iOS/" title="iOS">iOS<sup>9</sup></a></li>
			
		
			
				<li><a href="/tags/Mac工具/" title="Mac工具">Mac工具<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/iOS工具/" title="iOS工具">iOS工具<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/随笔/" title="随笔">随笔<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/读书笔记/" title="读书笔记">读书笔记<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Python/" title="Python">Python<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">Links</p>
    <ul>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS</a>
</div>

  <div class="weiboshow">
  <p class="asidetitle">Weibo</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=null&verifier=b3593ceb&dpc=1"></iframe>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> 热爱移动开发，希望做一些有意思的事情。 <br/>
			路漫漫其修远兮，吾将上下而求索。</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/2211006995" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		<a href="https://github.com/cuitengtai" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2017 
		
		<a href="/about" target="_blank" title="tengtai">tengtai</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});   
</script>



<script type="text/javascript">
  var duoshuoQuery = {short_name:"tengtai"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 







<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?6b67bf9e170287a3bd896be4ecee8176";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Back to Top"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
